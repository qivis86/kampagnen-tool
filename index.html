<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>NPC & Orte</title>

<style>
  body { margin:0; background:#0b0c10; color:#e8e8e8; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }

  /* Mobile Topbar */
  .topbar{
    position: sticky; top: 0; z-index: 100;
    display: none;
    background: #0b0c10;
    border-bottom: 1px solid #242838;
    padding: 10px 12px;
    align-items: center;
    gap: 10px;
  }
  .topbar button{
    width: auto;
    padding: 10px 12px;
    border-radius: 10px;
    text-align: center;
    white-space: nowrap;
  }
  .topbar .title{
    font-weight: 600;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    flex: 1;
  }

  .app { display:grid; grid-template-columns:280px 340px 1fr; gap:12px; padding:12px; height:100vh; box-sizing:border-box; }
  .panel { background:#14161c; border:1px solid #242838; border-radius:12px; padding:12px; overflow:auto; }
  h1 { font-size:16px; margin:0 0 10px; }
  h2 { font-size:14px; margin:0 0 10px; opacity:.9; }
  .muted { font-size:12px; opacity:.75; }
  .grid { display:grid; gap:8px; }
  .hr { height:1px; background:#2a3042; margin:10px 0; }

  button { width:100%; background:#1b1f2b; color:#e8e8e8; border:1px solid #2a3042; border-radius:10px; padding:10px; cursor:pointer; text-align:left; }
  button:hover { background:#23283a; }
  button.active { outline:2px solid #6aa6ff; border-color:transparent; }
  button.center { text-align:center; }
  button.danger { border-color:#5a2a2a; }
  button:disabled { opacity:.55; cursor:not-allowed; }

  input, select { width:100%; padding:10px; background:#0f1117; color:#e8e8e8; border:1px solid #2a3042; border-radius:10px; box-sizing:border-box; }
  select { padding-right: 34px; }

  .npc-btn, .place-btn { display:grid; gap:2px; }
  .npc-btn .sub, .place-btn .sub { font-size:12px; opacity:.75; }

  .pillwrap { display:flex; flex-wrap:wrap; gap:8px; margin-bottom:10px; }
  .pill { font-size:12px; background:#0f1117; border:1px solid #2a3042; padding:4px 8px; border-radius:999px; opacity:.9; }

  .kv { display:grid; grid-template-columns:220px 1fr; gap:8px; }
  .k { font-size:12px; opacity:.7; }
  .v { white-space:pre-wrap; }

  .actions { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  .actions button{ width:auto; padding:8px 10px; }

  /* Mode toggle */
  .seg { display:flex; gap:8px; }
  .seg button{ flex:1; text-align:center; }

  .modal-bg { position:fixed; inset:0; background:rgba(0,0,0,.6); display:none; align-items:center; justify-content:center; padding:14px; z-index:200; }
  .modal { background:#14161c; border:1px solid #2a3042; border-radius:12px; width:min(980px,100%); max-height:90vh; display:grid; grid-template-rows:auto 1fr auto; overflow:hidden; height:90vh; }
  .modal header, .modal footer { padding:10px; background:#10131a; }
  .modal footer { border-top:1px solid #2a3042; }
  textarea { width:100%; height:100%; min-height:60vh; background:#0f1117; color:#e8e8e8; border:none; padding:10px; box-sizing:border-box;
            font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
            font-size:13px; line-height:1.35; resize:none; outline:none; }
  .row { display:flex; gap:8px; flex-wrap:wrap; }
  .row > * { flex:1; min-width: 180px; }

  .smallseg { display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; }
  .smallseg button{ flex:1; text-align:center; padding:8px; min-width: 140px; }

  code { background:#0f1117; border:1px solid #2a3042; padding:0 6px; border-radius:8px; }

  .toast{
    position:fixed; left:50%; bottom:16px; transform:translateX(-50%);
    background:#10131a; border:1px solid #2a3042; color:#e8e8e8;
    padding:10px 12px; border-radius:12px; font-size:13px;
    box-shadow:0 10px 30px rgba(0,0,0,.35);
    opacity:0; pointer-events:none; transition:opacity .18s ease;
    z-index:300;
  }
  .toast.show{ opacity:1; }

  /* Toolbox */
  .tb-card{
    background:#10131a;
    border:1px solid #2a3042;
    border-radius:12px;
    padding:10px;
    display:grid;
    gap:8px;
  }
  .tb-row{
    display:flex;
    gap:8px;
    align-items:center;
    flex-wrap:wrap;
  }
  .tb-row > *{ flex: 0 0 auto; }
  .tb-row .grow{ flex: 1 1 auto; min-width: 180px; }
  .tb-label{ font-size:12px; opacity:.8; }
  .tb-value{ font-size:14px; font-weight:600; }
  .tb-mini{ font-size:12px; opacity:.75; }
  .tb-btns{ display:flex; gap:8px; flex-wrap:wrap; }
  .tb-btns button{ width:auto; text-align:center; }

  .seed-btn{
    display:grid; gap:4px;
  }
  .seed-btn .title{ font-weight:600; }
  .seed-btn .meta{ font-size:12px; opacity:.75; }
  .seed-btn .mini{ font-size:12px; opacity:.7; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }

  @media (max-width: 900px){
    .topbar{ display:flex; }
    .app{ grid-template-columns: 1fr; height:auto; padding-top:0; }
    .panel{ border-radius:0; border-left:0; border-right:0; border-top:0; padding-top:10px; }
    .panel[data-mobile-hidden="true"]{ display:none; }
    .kv { grid-template-columns:1fr; }
  }
</style>
</head>

<body>

<div class="toast" id="toast"></div>

<!-- Mobile Topbar -->
<div class="topbar" id="topbar">
  <button id="btnBack">‚Üê Zur√ºck</button>
  <div class="title" id="topbarTitle">Kategorien</div>
  <button id="btnTopMode" title="Modus wechseln">üßë</button>
  <button id="btnTopSync" title="Sync laden">üîÑ</button>
</div>

<div class="app">
  <!-- Navigation -->
  <div class="panel" id="panelCats">
    <h1 id="catsHeader">üìö Kategorien</h1>

    <div class="seg" style="margin-bottom:10px;">
      <button id="btnModeNpcs" class="active">üßë NPCs</button>
      <button id="btnModePlaces">üìç Orte</button>
    </div>

    <button id="btnModeToolbox" class="center" style="margin-bottom:10px;">üé≤ NPC-Toolbox</button>

    <div class="muted" id="catsHint">Klick ‚Üí Liste</div>
    <div class="hr"></div>

    <div id="catsArea">
      <div class="grid" id="catButtons"></div>
    </div>

    <div id="toolboxArea" style="display:none;">
      <div class="grid">
        <button id="btnTbTabBlocks" class="active">üß© Bausteine</button>
        <button id="btnTbTabSeeds">üì¶ Seeds</button>
      </div>
      <div class="hr"></div>

      <div class="tb-card">
        <div class="tb-row">
          <div class="grow">
            <div class="tb-label">Ziehen-Modus</div>
            <div class="tb-mini">Steuert, ob ‚ÄûZiehen‚Äú nur Unbenutzte nimmt.</div>
          </div>
          <button id="btnTbToggleUnused" class="center">‚úÖ Nur unbenutzt</button>
        </div>
      </div>
    </div>

    <div class="hr"></div>
    <div class="grid">
      <button id="btnSyncLoad" class="center">üîÑ Sync laden</button>
      <button id="btnImport" class="center">‚¨áÔ∏è Import</button>
      <button id="btnExportClipboard" class="center">üìã Export JSON (Clipboard)</button>
      <button id="btnExport" class="center">‚¨ÜÔ∏è Export (World JSON)</button>
      <button id="btnReset" class="center danger">üß® Reset</button>
    </div>
    <div class="hr"></div>
    <div class="muted" id="syncStatus">Sync: ‚Äî</div>
    <div class="muted">Alles wird lokal im Browser gespeichert (localStorage).</div>
  </div>

  <!-- Liste -->
  <div class="panel" id="panelList">
    <input id="search" placeholder="üîé Suche nach Name/Tags/Feldern‚Ä¶" />
    <div class="hr"></div>
    <h2 id="listTitle">Kategorie w√§hlen</h2>
    <div class="grid" id="entityList"></div>
  </div>

  <!-- Detail -->
  <div class="panel" id="panelDetail">
    <div class="actions" id="detailActions" style="display:none;">
      <button id="btnEditEntity">‚úèÔ∏è Edit</button>
      <button id="btnCopyId">üÜî ID kopieren</button>
      <span class="muted" id="detailIdHint" style="margin-left:auto;"></span>
    </div>
    <div class="hr" id="detailActionsHr" style="display:none;"></div>

    <h2 id="detailTitle">Ausw√§hlen</h2>
    <div class="muted" id="detailSub">‚Äî</div>
    <div class="hr"></div>
    <div id="detailBody">‚Äî</div>
  </div>
</div>

<!-- Import Modal -->
<div class="modal-bg" id="importBg">
  <div class="modal">
    <header>
      <div style="font-weight:600;" id="importHeaderTitle">‚¨áÔ∏è Import</div>
      <div class="muted" style="margin-top:4px;" id="importHeaderHint">
        NPCs: Textbl√∂cke wie bisher. Orte: braucht <code>**ID:**</code> (strict). Toolbox: Pools/Seeds.
      </div>

      <div class="smallseg">
        <button id="btnImportModeNpcs" class="active">üßë NPCs</button>
        <button id="btnImportModePlaces">üìç Orte</button>
        <button id="btnImportModeToolbox">üé≤ Toolbox</button>
      </div>

      <div id="toolboxImportControls" style="display:none; margin-top:10px;">
        <div class="row">
          <div>
            <div class="muted" style="margin-bottom:6px;">Ziel</div>
            <select id="tbImportTarget">
              <option value="names.human">names.human</option>
              <option value="names.dwarf">names.dwarf</option>
              <option value="names.elf">names.elf</option>
              <option value="roles">roles</option>
              <option value="traits">traits</option>
              <option value="hooks">hooks</option>
              <option value="voices">voices</option>
              <option value="seeds">seeds</option>
            </select>
          </div>
          <div>
            <div class="muted" style="margin-bottom:6px;">Import-Modus</div>
            <select id="tbImportMode">
              <option value="append">Anh√§ngen (empfohlen)</option>
              <option value="replace">Ersetzen</option>
            </select>
          </div>
        </div>
      </div>

      <div class="muted" style="margin-top:8px;" id="importFormatHelp"></div>
    </header>

    <textarea id="importText" placeholder="Hier reinpasten ‚Ä¶"></textarea>

    <footer>
      <div class="row">
        <button id="btnDoImport" class="center">‚úÖ Importieren</button>
        <button id="btnCloseImport" class="center">‚úñ Schlie√üen</button>
      </div>
      <div class="muted" id="importInfo" style="margin-top:8px;"></div>
    </footer>
  </div>
</div>

<!-- Edit Modal -->
<div class="modal-bg" id="editBg">
  <div class="modal">
    <header>
      <div style="font-weight:600;">‚úèÔ∏è Bearbeiten</div>
      <div class="muted" style="margin-top:4px;">
        Links strikt als IDs pflegen:
        NPC: <code>**Orte:** id1, id2</code> ¬∑ Ort: <code>**NPCs:** id1, id2</code>.
      </div>
    </header>
    <textarea id="editText" placeholder="Text ‚Ä¶"></textarea>
    <footer>
      <div class="row">
        <button id="btnSaveEdit" class="center">üíæ Speichern</button>
        <button id="btnCancelEdit" class="center">‚úñ Abbrechen</button>
      </div>
      <div class="muted" id="editInfo" style="margin-top:8px;"></div>
    </footer>
  </div>
</div>

<script>
/* =========================
   CONFIG
========================= */
const REMOTE_DATA_URL = "data/data.json";

/* =========================
   STORAGE (inkl. Toolbox)
========================= */
const STORAGE_KEY = "npc_places_links_app_v3_toolbox_seeds";
let { NPCS, PLACES, TOOLBOX } = loadWorld();

function makeDefaultToolbox(){
  return {
    settings: {
      onlyUnused: true,
      defaultCategory: "Toolbox/Spontan",
      defaultPlaceId: ""
    },
    pools: {
      names: {
        human: ["Mara","Elly","Finn","Bram","Toblen","Halia","Linene","Harbin"],
        dwarf: ["Gundren","Nundro","Tharden"],
        elf: ["Syla","Aelar","Naivara"]
      },
      roles: ["Wirt", "H√§ndlerin", "Wache", "Bote", "Minenarbeiter", "Heilerin", "Schmied", "J√§ger"],
      traits: ["√ºberh√∂flich", "misstrauisch", "redet zu viel", "immer nerv√∂s", "sehr direkt", "l√§chelt nie"],
      hooks: ["hat Schulden bei jemandem", "hat etwas Unheimliches gesehen", "sucht eine Person", "will nur in Ruhe gelassen werden"],
      voices: ["spricht sehr leise", "rollt das R", "lacht an falschen Stellen", "spricht in kurzen Befehlen"]
    },
    seeds: [
      {
        id: "seed-stonehill-regular",
        label: "Stammgast im Stonehill",
        tags: ["Phandalin","Stonehill Inn"],
        note: "Kennt jedes Ger√ºcht ‚Äì aber nie die ganze Wahrheit.",
        role: "Stammgast",
        hook: "hat etwas geh√∂rt, will aber erst sicher sein, dass du vertrauensw√ºrdig bist",
        voice: "spricht in Andeutungen"
      },
      {
        id: "seed-tired-guard",
        label: "M√ºde Wache",
        tags: ["Phandalin","Guard"],
        note: "Will eigentlich nur nach Hause.",
        role: "Wache",
        trait: "m√ºde, aber pflichtbewusst",
        hook: "hat letzte Nacht eine Gestalt am Ortsrand gesehen"
      }
    ],
    used: {
      "names.human": [],
      "names.dwarf": [],
      "names.elf": [],
      "roles": [],
      "traits": [],
      "hooks": [],
      "voices": [],
      "seeds": []
    },
    current: {
      name: null,
      role: null,
      trait1: null,
      trait2: null,
      hook: null,
      voice: null,
      seedId: null
    }
  };
}

function loadWorld(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    const parsed = raw ? JSON.parse(raw) : null;

    if(parsed && typeof parsed === "object" && (Array.isArray(parsed.npcs) || Array.isArray(parsed.places) || parsed.toolbox)){
      return {
        NPCS: Array.isArray(parsed.npcs)? parsed.npcs : [],
        PLACES: Array.isArray(parsed.places)? parsed.places : [],
        TOOLBOX: (parsed.toolbox && typeof parsed.toolbox === "object") ? parsed.toolbox : makeDefaultToolbox()
      };
    }

    if(Array.isArray(parsed)) return { NPCS: parsed, PLACES: [], TOOLBOX: makeDefaultToolbox() };

    return { NPCS: [], PLACES: [], TOOLBOX: makeDefaultToolbox() };
  }catch{
    return { NPCS: [], PLACES: [], TOOLBOX: makeDefaultToolbox() };
  }
}
function saveWorld(){
  localStorage.setItem(STORAGE_KEY, JSON.stringify({ npcs: NPCS, places: PLACES, toolbox: TOOLBOX }));
}

/* =========================
   TOAST
========================= */
const toastEl = document.getElementById("toast");
let toastTimer = null;
function showToast(msg){
  toastEl.textContent = msg;
  toastEl.classList.add("show");
  if(toastTimer) clearTimeout(toastTimer);
  toastTimer = setTimeout(()=>toastEl.classList.remove("show"), 1400);
}

/* =========================
   HELPERS
========================= */
function escapeHtml(s){
  return String(s ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"quot;")
    .replaceAll("'","&#039;");
}
function normalizeLine(line){
  return String(line || "").replace(/\u00A0/g, " ").trim();
}
function stripMarkdownBold(s){
  const t = String(s || "").trim();
  return t.replace(/^\*\*(.+?)\*\*$/s, "$1").trim();
}
function extractNameFromLine(line){
  const t = normalizeLine(line);
  const h = t.match(/^#{1,6}\s+(.+)$/);
  return h ? h[1].trim() : t;
}
function isSeparatorLine(line){
  const t = normalizeLine(line);
  return t === "----" || t === "---" || t === "‚Äî" || /^-{3,}$/.test(t);
}
function isNpcStartLine(line){
  const raw = String(line || "");
  const t = normalizeLine(raw);
  if(!t) return false;
  if(isSeparatorLine(t)) return false;
  if(/^\s*[*\-‚Ä¢]\s+/.test(raw)) return false;
  if(/^#{1,6}\s+/.test(t)) return true;
  if(t.includes(":")) return false;
  const first = t[0];
  const looksEmoji = first && !(/[A-Za-z0-9√Ñ√ñ√ú√§√∂√º√ü]/.test(first));
  return looksEmoji && t.length >= 3;
}
function slugifyNameToId(name){
  let n = (name || "").trim();
  n = n.replace(/^#{1,6}\s+/, "").trim();
  n = n.replace(/^[^A-Za-z0-9√Ñ√ñ√ú√§√∂√º√ü]+/, "").trim();
  n = n.toLowerCase();
  n = n.replaceAll("√§","ae").replaceAll("√∂","oe").replaceAll("√º","ue").replaceAll("√ü","ss");
  n = n.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
  n = n.replace(/["‚Äû‚Äú'‚Äô`¬¥]/g, "");
  n = n.replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "");
  return n || ("id-" + Math.random().toString(16).slice(2));
}
function parseCommaList(value){
  return String(value || "").split(",").map(s => s.trim()).filter(Boolean);
}
function parseKeyValueLine(line){
  const raw = normalizeLine(line);
  const noBullet = raw.replace(/^[-*‚Ä¢]\s+/, "").trim();
  const m = noBullet.match(/^(.+?):\s*(.*)$/);
  if(!m) return null;
  let key = stripMarkdownBold(m[1].trim()).replace(/\*\*/g, "").trim();
  let value = String(m[2] ?? "").trim().replace(/\*\*/g, "").trim();
  return { key, value };
}
function uniq(arr){ return Array.from(new Set((arr || []).filter(Boolean))); }
function randPick(list){ if(!list || list.length===0) return null; return list[Math.floor(Math.random()*list.length)]; }
function deepClone(obj){ try { return structuredClone(obj); } catch { return JSON.parse(JSON.stringify(obj)); } }

function normalizeForMatch(name){
  let n = (name || "").trim();
  n = n.replace(/^#{1,6}\s+/, "").trim();
  n = n.replace(/^[^A-Za-z0-9√Ñ√ñ√ú√§√∂√º√ü]+/, "").trim();
  n = n.toLowerCase();
  n = n.replaceAll("√§","ae").replaceAll("√∂","oe").replaceAll("√º","ue").replaceAll("√ü","ss");
  n = n.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
  n = n.replace(/["‚Äû‚Äú'‚Äô`¬¥]/g, "");
  n = n.replace(/[^a-z0-9]+/g, " ").trim();
  n = n.replace(/\s+/g, " ");
  return n;
}
function levenshtein(a, b){
  a = a || ""; b = b || "";
  const m = a.length, n = b.length;
  if(m === 0) return n;
  if(n === 0) return m;
  const dp = new Array(n + 1);
  for(let j=0; j<=n; j++) dp[j] = j;
  for(let i=1; i<=m; i++){
    let prev = dp[0];
    dp[0] = i;
    for(let j=1; j<=n; j++){
      const tmp = dp[j];
      const cost = (a[i-1] === b[j-1]) ? 0 : 1;
      dp[j] = Math.min(dp[j] + 1, dp[j-1] + 1, prev + cost);
      prev = tmp;
    }
  }
  return dp[n];
}
function similarity(a, b){
  const na = normalizeForMatch(a);
  const nb = normalizeForMatch(b);
  const maxLen = Math.max(na.length, nb.length);
  if(maxLen === 0) return 1;
  const dist = levenshtein(na, nb);
  return 1 - (dist / maxLen);
}
function findBestFuzzyMatch(importedNpc, existingNpcs){
  let best = null;
  for(const ex of existingNpcs){
    const score = similarity(importedNpc.name, ex.name);
    if(!best || score > best.score) best = { npc: ex, score };
  }
  return best;
}
function validateIds(list, existingSet){
  const unknown = (list || []).filter(id => id && !existingSet.has(id));
  return uniq(unknown);
}

/* =========================
   TOOLBOX MERGE (mergeUsed)
========================= */
function mergeToolbox(localTb, remoteTb, { mode } = { mode: "mergeUsed" }){
  const out = deepClone(localTb || makeDefaultToolbox());
  const r = remoteTb && typeof remoteTb === "object" ? remoteTb : {};

  if(r.settings && typeof r.settings === "object") out.settings = r.settings;
  if(r.pools && typeof r.pools === "object") out.pools = r.pools;
  if(Array.isArray(r.seeds)) out.seeds = r.seeds;

  const rUsed = (r.used && typeof r.used === "object") ? r.used : {};
  const lUsed = (out.used && typeof out.used === "object") ? out.used : {};

  if(mode === "remoteWins"){
    out.used = rUsed;
  } else {
    const keys = new Set([...Object.keys(lUsed), ...Object.keys(rUsed)]);
    out.used = {};
    for(const k of keys){
      const a = Array.isArray(lUsed[k]) ? lUsed[k] : [];
      const b = Array.isArray(rUsed[k]) ? rUsed[k] : [];
      out.used[k] = Array.from(new Set([...a, ...b]));
    }
  }

  if(localTb && localTb.current) out.current = localTb.current;

  return out;
}

/* =========================
   TOOLBOX CORE
========================= */
function makeDefaultToolboxIfMissing(){
  if(!TOOLBOX || typeof TOOLBOX !== "object") TOOLBOX = makeDefaultToolbox();
  if(!TOOLBOX.settings) TOOLBOX.settings = makeDefaultToolbox().settings;
  if(!TOOLBOX.pools) TOOLBOX.pools = makeDefaultToolbox().pools;
  if(!Array.isArray(TOOLBOX.seeds)) TOOLBOX.seeds = makeDefaultToolbox().seeds;
  if(!TOOLBOX.used) TOOLBOX.used = makeDefaultToolbox().used;
  if(!TOOLBOX.current) TOOLBOX.current = makeDefaultToolbox().current;
}
function tbEnsureUsedKeys(){
  const keys = ["names.human","names.dwarf","names.elf","roles","traits","hooks","voices","seeds"];
  TOOLBOX.used = TOOLBOX.used || {};
  for(const k of keys){
    if(!Array.isArray(TOOLBOX.used[k])) TOOLBOX.used[k] = [];
  }
}
function tbGetPoolItems(poolKey){
  if(poolKey.startsWith("names.")){
    const race = poolKey.split(".")[1];
    return (TOOLBOX.pools.names && TOOLBOX.pools.names[race]) ? TOOLBOX.pools.names[race] : [];
  }
  return (TOOLBOX.pools && TOOLBOX.pools[poolKey]) ? TOOLBOX.pools[poolKey] : [];
}
function tbGetUsedSet(poolKey){
  const used = TOOLBOX.used && TOOLBOX.used[poolKey] ? TOOLBOX.used[poolKey] : [];
  return new Set(used.map(String));
}
function tbItemId(poolKey, text){
  // stable enough for cross-device
  return poolKey + "::" + slugifyNameToId(String(text || ""));
}
function tbIsUsed(poolKey, text){
  const id = tbItemId(poolKey, text);
  return tbGetUsedSet(poolKey).has(id);
}
function tbMarkUsed(poolKey, text){
  const id = tbItemId(poolKey, text);
  if(!TOOLBOX.used[poolKey]) TOOLBOX.used[poolKey] = [];
  if(!TOOLBOX.used[poolKey].includes(id)) TOOLBOX.used[poolKey].push(id);
}
function tbUnmarkUsed(poolKey, text){
  const id = tbItemId(poolKey, text);
  TOOLBOX.used[poolKey] = (TOOLBOX.used[poolKey] || []).filter(x => x !== id);
}
function tbSeedKey(seed){
  return "seed::" + (seed.id || slugifyNameToId(seed.label || "seed"));
}
function tbSeedIsUsed(seed){
  const id = tbSeedKey(seed);
  return (TOOLBOX.used.seeds || []).includes(id);
}
function tbSeedMarkUsed(seed){
  const id = tbSeedKey(seed);
  if(!TOOLBOX.used.seeds) TOOLBOX.used.seeds = [];
  if(!TOOLBOX.used.seeds.includes(id)) TOOLBOX.used.seeds.push(id);
}
function tbSeedUnmarkUsed(seed){
  const id = tbSeedKey(seed);
  TOOLBOX.used.seeds = (TOOLBOX.used.seeds || []).filter(x => x !== id);
}
function tbDraw(poolKey){
  const items = tbGetPoolItems(poolKey).slice();
  if(items.length === 0) return null;

  if(TOOLBOX.settings.onlyUnused){
    const used = tbGetUsedSet(poolKey);
    const filtered = items.filter(t => !used.has(tbItemId(poolKey, t)));
    if(filtered.length > 0) return randPick(filtered);
  }
  return randPick(items);
}
function tbSetCurrent(slot, text){
  TOOLBOX.current[slot] = (text === null || text === undefined || text === "") ? null : String(text);
  saveWorld();
}
function tbPoolKeyFor(slot){
  if(slot === "name") return "names.human";
  if(slot === "role") return "roles";
  if(slot === "trait1" || slot === "trait2") return "traits";
  if(slot === "hook") return "hooks";
  if(slot === "voice") return "voices";
  return "";
}

/* =========================
   IMPORT PARSER UTILS
========================= */
function splitBlocks(rawText){
  const text = String(rawText || "").replace(/\r\n/g, "\n");
  const lines = text.split("\n");
  const blocks = [];
  let current = [];

  function pushCurrent(){
    const cleaned = current.join("\n").trim();
    if(cleaned) blocks.push(cleaned);
    current = [];
  }

  for(const line of lines){
    const t = normalizeLine(line);
    if(isSeparatorLine(t)){ pushCurrent(); continue; }
    if(/^#{1,6}\s+/.test(t) && current.join("\n").trim().length > 0){
      pushCurrent();
    }
    current.push(line);
  }
  pushCurrent();
  return blocks;
}

/* =========================
   IMPORT: NPCs
========================= */
function parseNpcBlocks(rawText){
  const blocks = splitBlocks(rawText);
  const parsed = [];
  const errors = [];

  blocks.forEach((block, idx) => {
    const raw = block.split("\n");
    const nonEmpty = raw.map(normalizeLine).filter(Boolean);
    if(nonEmpty.length === 0) return;

    const nameLine = nonEmpty[0];
    if(!isNpcStartLine(nameLine)){
      errors.push(`NPC Block ${idx+1}: Keine g√ºltige √úberschrift gefunden. Erste Zeile: "${nameLine}"`);
      return;
    }

    const name = extractNameFromLine(nameLine);
    const npc = { id: slugifyNameToId(name), name, categories: [], tags: [], placeIds: [], fields: {} };

    let currentSection = null;
    let lastKey = null;

    for(let i=1; i<raw.length; i++){
      const line = normalizeLine(raw[i]);
      if(!line) continue;
      if(isSeparatorLine(line)) continue;

      const kv = parseKeyValueLine(line);

      if(kv){
        const keyLower = kv.key.toLowerCase();

        if(keyLower === "kategorie" || keyLower === "kategorien"){ npc.categories = parseCommaList(kv.value); currentSection=null; lastKey=null; continue; }
        if(keyLower === "tag" || keyLower === "tags"){ npc.tags = parseCommaList(kv.value); currentSection=null; lastKey=null; continue; }
        if(keyLower === "orte" || keyLower === "ort" || keyLower === "place" || keyLower === "places"){ npc.placeIds = parseCommaList(kv.value); currentSection=null; lastKey=null; continue; }

        if(kv.value === ""){
          currentSection = kv.key;
          if(!(kv.key in npc.fields)) npc.fields[kv.key] = "";
          lastKey = kv.key;
          continue;
        }

        const rawLine = raw[i].trim();
        const isBullet = rawLine.startsWith("*") || rawLine.startsWith("-");
        let finalKey = kv.key;

        if(currentSection && isBullet){
          finalKey = `${currentSection} ‚Äì ${kv.key}`;
        } else {
          currentSection = null;
        }

        npc.fields[finalKey] = kv.value;
        lastKey = finalKey;
        continue;
      }

      if(lastKey){
        npc.fields[lastKey] = (npc.fields[lastKey] ? npc.fields[lastKey] + "\n" : "") + line;
      }
    }

    if(!npc.categories || npc.categories.length === 0) npc.categories = ["Unkategorisiert"];
    npc.placeIds = uniq(npc.placeIds);

    parsed.push(npc);
  });

  return { parsed, errors };
}

/* =========================
   IMPORT: PLACES
========================= */
function parsePlaceBlocks(rawText){
  const blocks = splitBlocks(rawText);
  const parsed = [];
  const errors = [];
  const warnings = [];

  blocks.forEach((block, idx) => {
    const raw = block.split("\n");
    const nonEmpty = raw.map(normalizeLine).filter(Boolean);
    if(nonEmpty.length === 0) return;

    const header = nonEmpty[0];
    if(!/^#{1,6}\s+/.test(header)){
      errors.push(`Ort Block ${idx+1}: Keine √úberschrift gefunden (erwarte "### Name"). Erste Zeile: "${header}"`);
      return;
    }

    const name = extractNameFromLine(header);
    const place = {
      id: "",
      name,
      type: "",
      parentId: "",
      categories: [],
      tags: [],
      npcIds: [],
      fields: {}
    };

    let lastKey = null;

    for(let i=1; i<raw.length; i++){
      const line = normalizeLine(raw[i]);
      if(!line) continue;
      if(isSeparatorLine(line)) continue;

      const kv = parseKeyValueLine(line);
      if(kv){
        const kLower = kv.key.toLowerCase();

        if(kLower === "id"){ place.id = kv.value.trim(); lastKey = null; continue; }
        if(kLower === "typ"){ place.type = kv.value.trim(); lastKey = null; continue; }
        if(kLower === "parent"){ place.parentId = kv.value.trim(); lastKey = null; continue; }
        if(kLower === "kategorien" || kLower === "kategorie"){ place.categories = parseCommaList(kv.value); lastKey = null; continue; }
        if(kLower === "tags" || kLower === "tag"){ place.tags = parseCommaList(kv.value); lastKey = null; continue; }
        if(kLower === "npcs" || kLower === "npc"){ place.npcIds = parseCommaList(kv.value); lastKey = null; continue; }

        place.fields[kv.key] = kv.value;
        lastKey = kv.key;
        continue;
      }

      if(lastKey){
        place.fields[lastKey] = (place.fields[lastKey] ? place.fields[lastKey] + "\n" : "") + line;
      }
    }

    if(!place.id){
      place.id = slugifyNameToId(place.name);
      warnings.push(`Ort Block ${idx+1}: Keine **ID:** gefunden ‚Üí ID automatisch gesetzt: ${place.id}`);
    }

    if(!place.categories || place.categories.length === 0) place.categories = ["Unkategorisiert"];
    place.npcIds = uniq(place.npcIds);

    parsed.push(place);
  });

  return { parsed, errors, warnings };
}

/* =========================
   IMPORT: TOOLBOX (Pools/Seeds)
========================= */
function getTbPoolRef(target){
  // returns { kind: "names", race } or { kind: "list", key }
  if(target.startsWith("names.")){
    return { kind:"names", race: target.split(".")[1] };
  }
  if(["roles","traits","hooks","voices"].includes(target)){
    return { kind:"list", key: target };
  }
  if(target === "seeds"){
    return { kind:"seeds" };
  }
  return null;
}

// Seeds line format (flexibel):
// Label | tag1, tag2 | note ... (note may include "name=..., role=..., hook=..., trait=..., voice=...")
function parseSeedLine(line){
  const parts = line.split("|").map(p => p.trim());
  const label = parts[0] || "";
  if(!label) return null;

  const tags = parts[1] ? parts[1].split(",").map(t=>t.trim()).filter(Boolean) : [];
  const noteRaw = parts.slice(2).join(" | ").trim();

  const seed = {
    id: "seed-" + slugifyNameToId(label),
    label,
    tags,
    note: noteRaw || ""
  };

  // Pull key=value pairs out of note
  // supports separators ; or , or line breaks
  const kvRegex = /\b(name|rolle|role|hook|trait|voice)\s*=\s*([^;,\n]+)\s*/ig;
  let m;
  while((m = kvRegex.exec(noteRaw)) !== null){
    const k = m[1].toLowerCase();
    const v = (m[2] || "").trim();
    if(!v) continue;
    if(k === "rolle") seed.role = v;
    else seed[k] = v;
  }

  return seed;
}

function parseToolboxImport(text, target){
  const raw = String(text || "").trim();
  if(!raw) return { items: [], seeds: [], errors: ["Leerer Import."] };

  // If user pastes JSON: accept arrays for pools, or {seeds:[...]} / world objects
  try{
    const maybe = JSON.parse(raw);
    if(Array.isArray(maybe)){
      if(target === "seeds"){
        const seeds = maybe
          .filter(x => x && typeof x === "object")
          .map(x => ({
            id: String(x.id || ("seed-" + slugifyNameToId(x.label || x.name || "seed"))),
            label: String(x.label || x.name || "Seed"),
            tags: Array.isArray(x.tags) ? x.tags.map(String) : [],
            note: x.note ? String(x.note) : "",
            name: x.name ? String(x.name) : undefined,
            role: x.role ? String(x.role) : undefined,
            hook: x.hook ? String(x.hook) : undefined,
            trait: x.trait ? String(x.trait) : undefined,
            voice: x.voice ? String(x.voice) : undefined,
          }));
        return { items: [], seeds, errors: [] };
      } else {
        const items = maybe.map(x => String(x)).map(s => s.trim()).filter(Boolean);
        return { items, seeds: [], errors: [] };
      }
    } else if(maybe && typeof maybe === "object"){
      // world json or toolbox json
      const tb = maybe.toolbox && typeof maybe.toolbox === "object" ? maybe.toolbox : maybe;
      if(target === "seeds"){
        const seedsArr = Array.isArray(tb.seeds) ? tb.seeds : (Array.isArray(tb) ? tb : []);
        const seeds = (seedsArr || [])
          .filter(x => x && typeof x === "object")
          .map(x => ({
            id: String(x.id || ("seed-" + slugifyNameToId(x.label || x.name || "seed"))),
            label: String(x.label || x.name || "Seed"),
            tags: Array.isArray(x.tags) ? x.tags.map(String) : [],
            note: x.note ? String(x.note) : "",
            name: x.name ? String(x.name) : undefined,
            role: x.role ? String(x.role) : undefined,
            hook: x.hook ? String(x.hook) : undefined,
            trait: x.trait ? String(x.trait) : undefined,
            voice: x.voice ? String(x.voice) : undefined,
          }));
        return { items: [], seeds, errors: [] };
      } else {
        // try to resolve a pool array in the object by target key
        if(target.startsWith("names.")){
          const race = target.split(".")[1];
          const arr = tb?.pools?.names?.[race];
          if(Array.isArray(arr)){
            const items = arr.map(x=>String(x)).map(s=>s.trim()).filter(Boolean);
            return { items, seeds: [], errors: [] };
          }
        } else {
          const arr = tb?.pools?.[target];
          if(Array.isArray(arr)){
            const items = arr.map(x=>String(x)).map(s=>s.trim()).filter(Boolean);
            return { items, seeds: [], errors: [] };
          }
        }
        // fallback: if object itself has property
        const direct = maybe[target];
        if(Array.isArray(direct)){
          const items = direct.map(x=>String(x)).map(s=>s.trim()).filter(Boolean);
          return { items, seeds: [], errors: [] };
        }
      }
    }
  }catch{
    // not json => continue as text
  }

  // Text format
  const lines = raw.replace(/\r\n/g,"\n").split("\n")
    .map(l => l.trim())
    .filter(l => l && !l.startsWith("#") && !l.startsWith("//"));

  if(target === "seeds"){
    const seeds = [];
    const errors = [];
    for(const line of lines){
      const seed = parseSeedLine(line);
      if(!seed) errors.push("Konnte Seed nicht lesen: " + line);
      else seeds.push(seed);
    }
    return { items: [], seeds, errors };
  } else {
    const items = lines.map(l => l.replace(/^-+\s*/,"").trim()).filter(Boolean);
    return { items, seeds: [], errors: [] };
  }
}

/* =========================
   Textblocks (Edit)
========================= */
function addFieldLines(lines, key, value){
  const val = String(value ?? "");
  const parts = val.split("\n");
  lines.push(`**${key}:** ${parts[0] ?? ""}`.trimEnd());
  for(let i=1; i<parts.length; i++) lines.push(parts[i]);
}
function addBulletFieldLines(lines, key, value){
  const val = String(value ?? "");
  const parts = val.split("\n");
  lines.push(`* **${key}:** ${parts[0] ?? ""}`.trimEnd());
  for(let i=1; i<parts.length; i++) lines.push(parts[i]);
}

function npcToTextBlock(npc){
  const lines = [];
  lines.push(`### ${npc.name}`);
  if(npc.categories?.length) lines.push(`**Kategorien:** ${npc.categories.join(", ")}`);
  if(npc.tags?.length) lines.push(`**Tags:** ${npc.tags.join(", ")}`);
  if(npc.placeIds?.length) lines.push(`**Orte:** ${npc.placeIds.join(", ")}`);
  lines.push("");

  const sectionMap = new Map();
  const normalFields = [];

  for(const [k, v] of Object.entries(npc.fields || {})){
    const m = k.match(/^(.*?)\s+‚Äì\s+(.*)$/);
    if(m){
      const section = m[1].trim();
      const subkey = m[2].trim();
      if(!sectionMap.has(section)) sectionMap.set(section, []);
      sectionMap.get(section).push({ subkey, value: v });
    }else{
      normalFields.push([k, v]);
    }
  }

  normalFields.sort((a,b) => a[0].localeCompare(b[0], 'de'));
  for(const [k, v] of normalFields){
    addFieldLines(lines, k, v);
    lines.push("");
  }

  const sections = Array.from(sectionMap.keys()).sort((a,b)=>a.localeCompare(b,'de'));
  for(const section of sections){
    lines.push(`**${section}:**`);
    const items = sectionMap.get(section);
    items.sort((a,b)=>a.subkey.localeCompare(b.subkey,'de'));
    for(const it of items){
      addBulletFieldLines(lines, it.subkey, it.value);
    }
    lines.push("");
  }

  while(lines.length && lines[lines.length-1].trim()==="") lines.pop();
  return lines.join("\n");
}

function placeToTextBlock(place){
  const lines = [];
  lines.push(`### ${place.name}`);
  lines.push(`**ID:** ${place.id}`);
  if(place.type) lines.push(`**Typ:** ${place.type}`);
  if(place.parentId) lines.push(`**Parent:** ${place.parentId}`);
  if(place.categories?.length) lines.push(`**Kategorien:** ${place.categories.join(", ")}`);
  if(place.tags?.length) lines.push(`**Tags:** ${place.tags.join(", ")}`);
  if(place.npcIds?.length) lines.push(`**NPCs:** ${place.npcIds.join(", ")}`);
  lines.push("");

  const normalFields = Object.entries(place.fields || {}).sort((a,b)=>a[0].localeCompare(b[0],'de'));
  for(const [k,v] of normalFields){
    addFieldLines(lines, k, v);
    lines.push("");
  }

  while(lines.length && lines[lines.length-1].trim()==="") lines.pop();
  return lines.join("\n");
}

/* =========================
   MOBILE VIEW STATE
========================= */
function isMobile(){ return window.matchMedia && window.matchMedia("(max-width: 900px)").matches; }
const panels = { cats: document.getElementById("panelCats"), list: document.getElementById("panelList"), detail: document.getElementById("panelDetail") };
const topbarTitle = document.getElementById("topbarTitle");
const btnBack = document.getElementById("btnBack");
const btnTopSync = document.getElementById("btnTopSync");
const btnTopMode = document.getElementById("btnTopMode");

const state = {
  mode: "npcs", // "npcs" | "places" | "toolbox"
  selectedCategory: null,
  selectedEntityId: null,
  search: "",
  view: "cats",
  tbTab: "blocks", // "blocks" | "seeds"
  selectedSeedId: null
};

function setView(v){ state.view = v; applyMobileVisibility(); }
function setMode(mode){
  state.mode = mode;
  state.selectedCategory = null;
  state.selectedEntityId = null;
  state.search = "";
  state.selectedSeedId = null;
  elSearch.value = "";
  state.view = "cats";
  updateModeUi();
  renderAll();
  applyMobileVisibility();
}

function applyMobileVisibility(){
  if(!isMobile()){
    panels.cats.dataset.mobileHidden = "false";
    panels.list.dataset.mobileHidden = "false";
    panels.detail.dataset.mobileHidden = "false";
    return;
  }
  panels.cats.dataset.mobileHidden = (state.view !== "cats") ? "true" : "false";
  panels.list.dataset.mobileHidden = (state.view !== "list") ? "true" : "false";
  panels.detail.dataset.mobileHidden = (state.view !== "detail") ? "true" : "false";

  let title = "Kategorien";
  let backEnabled = false;
  if(state.view === "list"){
    title = state.mode === "toolbox" ? "Toolbox" : (state.selectedCategory || "Liste");
    backEnabled = true;
  } else if(state.view === "detail"){
    if(state.mode === "toolbox") title = "Toolbox";
    else { const ent = getSelectedEntity(); title = ent ? ent.name : "Detail"; }
    backEnabled = true;
  }

  topbarTitle.textContent = title;
  btnBack.disabled = !backEnabled;
  btnTopMode.textContent = (state.mode === "places") ? "üìç" : (state.mode === "toolbox" ? "üé≤" : "üßë");
}
btnBack.onclick = () => { if(state.view === "detail") setView("list"); else if(state.view === "list") setView("cats"); else setView("cats"); };
btnTopSync.onclick = () => syncLoad();
btnTopMode.onclick = () => { if(state.mode === "places") setMode("npcs"); else setMode("places"); };
window.addEventListener("resize", () => applyMobileVisibility());

/* =========================
   UI ELEMENTS
========================= */
const elCatButtons = document.getElementById("catButtons");
const elEntityList = document.getElementById("entityList");
const elListTitle = document.getElementById("listTitle");
const elSearch = document.getElementById("search");
const elDetailTitle = document.getElementById("detailTitle");
const elDetailSub = document.getElementById("detailSub");
const elDetailBody = document.getElementById("detailBody");
const elSyncStatus = document.getElementById("syncStatus");

const elDetailActions = document.getElementById("detailActions");
const elDetailActionsHr = document.getElementById("detailActionsHr");
const btnEditEntity = document.getElementById("btnEditEntity");
const btnCopyId = document.getElementById("btnCopyId");
const detailIdHint = document.getElementById("detailIdHint");

const btnModeNpcs = document.getElementById("btnModeNpcs");
const btnModePlaces = document.getElementById("btnModePlaces");
const btnModeToolbox = document.getElementById("btnModeToolbox");
const catsHeader = document.getElementById("catsHeader");
const catsHint = document.getElementById("catsHint");

const catsArea = document.getElementById("catsArea");
const toolboxArea = document.getElementById("toolboxArea");
const btnTbToggleUnused = document.getElementById("btnTbToggleUnused");

const btnTbTabBlocks = document.getElementById("btnTbTabBlocks");
const btnTbTabSeeds = document.getElementById("btnTbTabSeeds");

btnModeNpcs.onclick = () => setMode("npcs");
btnModePlaces.onclick = () => setMode("places");
btnModeToolbox.onclick = () => setMode("toolbox");

btnTbTabBlocks.onclick = () => { state.tbTab = "blocks"; renderAll(); if(isMobile()) setView("list"); };
btnTbTabSeeds.onclick = () => { state.tbTab = "seeds"; renderAll(); if(isMobile()) setView("list"); };

btnTbToggleUnused.onclick = () => {
  TOOLBOX.settings.onlyUnused = !TOOLBOX.settings.onlyUnused;
  saveWorld();
  renderAll();
};

function updateModeUi(){
  const isNpc = state.mode === "npcs";
  const isPlace = state.mode === "places";
  const isTb = state.mode === "toolbox";

  btnModeNpcs.classList.toggle("active", isNpc);
  btnModePlaces.classList.toggle("active", isPlace);
  btnModeToolbox.classList.toggle("active", isTb);

  catsArea.style.display = isTb ? "none" : "block";
  toolboxArea.style.display = isTb ? "block" : "none";

  btnTbTabBlocks.classList.toggle("active", state.tbTab === "blocks");
  btnTbTabSeeds.classList.toggle("active", state.tbTab === "seeds");

  if(isTb){
    catsHeader.textContent = "üé≤ NPC-Toolbox";
    catsHint.textContent = state.tbTab === "seeds" ? "Seeds ausw√§hlen/ziehen" : "Bausteine ziehen & einzeln als benutzt markieren";
    btnTbToggleUnused.textContent = TOOLBOX.settings.onlyUnused ? "‚úÖ Nur unbenutzt" : "‚ôªÔ∏è Auch benutzte";
  } else {
    catsHeader.textContent = isNpc ? "üìö Kategorien (NPCs)" : "üìö Kategorien (Orte)";
    catsHint.textContent = isNpc ? "Klick ‚Üí NPC-Liste" : "Klick ‚Üí Orte-Liste";
  }

  elSearch.disabled = isTb;
  elSearch.placeholder = isTb ? "Toolbox nutzt keine Suche (in der Liste)" : "üîé Suche nach Name/Tags/Feldern‚Ä¶";
}

/* =========================
   DATA ACCESS
========================= */
function getEntities(){ return (state.mode === "npcs") ? NPCS : (state.mode === "places" ? PLACES : []); }
function getSelectedEntity(){ return getEntities().find(e => e.id === state.selectedEntityId) || null; }

function collectCategories(list){
  const set = new Set();
  list.forEach(n => (n.categories || []).forEach(c => set.add(c)));
  if(set.size === 0) set.add("Unkategorisiert");
  return Array.from(set).sort((a,b) => a.localeCompare(b, 'de'));
}
function matchesSearch(entity, q){
  if(!q) return true;
  const hay = [
    entity.name,
    ...(entity.categories || []),
    ...(entity.tags || []),
    ...(entity.fields ? Object.values(entity.fields) : []),
    (entity.type || ""),
    ...(entity.placeIds || []),
    ...(entity.npcIds || []),
  ].join(" ").toLowerCase();
  return hay.includes(q.toLowerCase());
}
function getVisibleEntities(){
  let list = getEntities().slice();
  if(state.selectedCategory) list = list.filter(n => (n.categories || []).includes(state.selectedCategory));
  if(state.search) list = list.filter(n => matchesSearch(n, state.search));
  list.sort((a,b) => (a.name || "").localeCompare(b.name || "", 'de'));
  return list;
}

/* =========================
   NAV HELPERS (strict IDs)
========================= */
function openNpcById(npcId){
  setMode("npcs");
  const npc = NPCS.find(n => n.id === npcId);
  if(!npc){ alert(`NPC-ID nicht gefunden: ${npcId}`); return; }
  state.selectedEntityId = npcId;
  state.selectedCategory = (npc.categories && npc.categories.length) ? npc.categories[0] : "Unkategorisiert";
  renderAll();
  if(isMobile()) setView("detail");
  applyMobileVisibility();
}
function openPlaceById(placeId){
  setMode("places");
  const p = PLACES.find(x => x.id === placeId);
  if(!p){ alert(`Ort-ID nicht gefunden: ${placeId}`); return; }
  state.selectedEntityId = placeId;
  state.selectedCategory = (p.categories && p.categories.length) ? p.categories[0] : "Unkategorisiert";
  renderAll();
  if(isMobile()) setView("detail");
  applyMobileVisibility();
}
window.__openNpc = openNpcById;
window.__openPlace = openPlaceById;

/* =========================
   RENDER: Kategorien (NPC/Orte)
========================= */
function renderCategories(){
  const cats = collectCategories(getEntities());
  elCatButtons.innerHTML = "";
  cats.forEach(cat => {
    const btn = document.createElement("button");
    btn.textContent = cat;
    btn.className = (state.selectedCategory === cat) ? "active" : "";
    btn.onclick = () => {
      state.selectedCategory = cat;
      state.selectedEntityId = null;
      renderCategories();
      renderEntityList();
      renderDetail(null);
      if(isMobile()) setView("list");
      applyMobileVisibility();
    };
    elCatButtons.appendChild(btn);
  });
}

/* =========================
   TOOLBOX: Seeds helpers
========================= */
function getSeedById(id){
  return (TOOLBOX.seeds || []).find(s => (s.id || ("seed-"+slugifyNameToId(s.label))) === id) || null;
}
function seedSummary(seed){
  const bits = [];
  if(seed.name) bits.push("Name");
  if(seed.role) bits.push("Rolle");
  if(seed.hook) bits.push("Hook");
  if(seed.trait) bits.push("Trait");
  if(seed.voice) bits.push("Voice");
  return bits.length ? ("Enth√§lt: " + bits.join(", ")) : "Nur Text";
}
function seedMeta(seed){
  const tags = (seed.tags || []).slice(0,4).join(" ¬∑ ");
  return tags || "‚Äî";
}
function seedParts(seed){
  return [
    { key:"name", label:"Name", poolKey:"names.human", value: seed.name },
    { key:"role", label:"Rolle", poolKey:"roles", value: seed.role },
    { key:"hook", label:"Hook", poolKey:"hooks", value: seed.hook },
    { key:"trait", label:"Trait", poolKey:"traits", value: seed.trait },
    { key:"voice", label:"Voice", poolKey:"voices", value: seed.voice },
  ].filter(p => p.value);
}

/* =========================
   RENDER: Liste
========================= */
function renderEntityList(){
  elEntityList.innerHTML = "";

  if(state.mode === "toolbox"){
    renderToolboxList();
    return;
  }

  if(!state.selectedCategory){
    elListTitle.textContent = "Kategorie w√§hlen";
    return;
  }
  const visible = getVisibleEntities();
  elListTitle.textContent = `${state.selectedCategory} (${visible.length})`;

  visible.forEach(ent => {
    const btn = document.createElement("button");
    const isActive = state.selectedEntityId === ent.id;
    btn.className = (state.mode === "npcs" ? "npc-btn" : "place-btn") + (isActive ? " active" : "");

    const sub =
      state.mode === "npcs"
        ? (ent.fields?.["Rolle / Funktion"] || ent.fields?.["Rolle"] || "")
        : (ent.type || (ent.parentId ? "Unterort" : "Ort"));

    const tags = (ent.tags || []).slice(0,4).join(" ¬∑ ");

    btn.innerHTML = `
      <div><b>${escapeHtml(ent.name)}</b></div>
      <div class="sub">${escapeHtml(sub)}${tags ? " ¬∑ " + escapeHtml(tags) : ""}</div>
    `;

    btn.onclick = () => {
      state.selectedEntityId = ent.id;
      renderEntityList();
      renderDetail(ent);
      if(isMobile()) setView("detail");
      applyMobileVisibility();
    };

    elEntityList.appendChild(btn);
  });
}

/* =========================
   TOOLBOX UI
========================= */
function renderToolboxList(){
  tbEnsureUsedKeys();

  if(state.tbTab === "seeds"){
    renderSeedsList();
    return;
  }

  // Blocks tab
  elListTitle.textContent = "üé≤ Toolbox ‚Äì Bausteine";
  elEntityList.innerHTML = "";

  const cards = [
    { slot: "name", label: "üßë Name (Human)", poolKey: "names.human", hint: "Zieh dir nur einen Namen, ohne alles andere zu verbrauchen." },
    { slot: "role", label: "üß∞ Rolle/Job", poolKey: "roles", hint: "Z.B. Wirt, Wache, H√§ndlerin ‚Ä¶" },
    { slot: "trait1", label: "‚ú® Trait 1", poolKey: "traits", hint: "Charakterzug, Verhalten, Tick" },
    { slot: "trait2", label: "‚ú® Trait 2", poolKey: "traits", hint: "Optionaler zweiter Trait" },
    { slot: "hook", label: "ü™ù Hook", poolKey: "hooks", hint: "Motivation/Problem/Ankn√ºpfung" },
    { slot: "voice", label: "üé≠ Voice/Marotte", poolKey: "voices", hint: "Sprechweise, Marotte, K√∂rpersprache" },
  ];

  for(const c of cards){
    const current = TOOLBOX.current[c.slot];
    const isUsed = current ? tbIsUsed(c.poolKey, current) : false;
    const total = tbGetPoolItems(c.poolKey).length;
    const usedCount = (TOOLBOX.used[c.poolKey] || []).length;

    const wrap = document.createElement("div");
    wrap.className = "tb-card";

    wrap.innerHTML = `
      <div class="tb-row">
        <div class="grow">
          <div class="tb-value">${escapeHtml(c.label)}</div>
          <div class="tb-mini">${escapeHtml(c.hint)} ¬∑ <span class="muted">Pool: ${escapeHtml(c.poolKey)}</span></div>
        </div>
        <button class="center" data-action="draw">üé≤ Ziehen</button>
      </div>

      <div class="tb-row">
        <div class="grow">
          <div class="tb-label">Aktuell</div>
          <div class="tb-value">${current ? escapeHtml(current) : "<span class='muted'>‚Äî</span>"}</div>
          <div class="tb-mini">${escapeHtml(`Eintr√§ge: ${total} ¬∑ benutzt: ${usedCount}`)}${current ? ` ¬∑ Status: ${isUsed ? "‚úÖ benutzt" : "üÜï unbenutzt"}` : ""}</div>
        </div>
      </div>

      <div class="tb-btns">
        <button data-action="copy" ${current ? "" : "disabled"}>üìã Copy</button>
        <button data-action="mark" ${current ? "" : "disabled"}>${isUsed ? "‚Ü©Ô∏é Unbenutzt" : "‚úÖ Benutzt"}</button>
        <button data-action="reroll" ${current ? "" : "disabled"}>üîÅ Neu</button>
      </div>
    `;

    const btnDraw = wrap.querySelector('[data-action="draw"]');
    const btnCopy = wrap.querySelector('[data-action="copy"]');
    const btnMark = wrap.querySelector('[data-action="mark"]');
    const btnReroll = wrap.querySelector('[data-action="reroll"]');

    btnDraw.onclick = () => {
      const value = tbDraw(c.poolKey);
      if(!value){ showToast("Pool ist leer: " + c.poolKey); return; }
      tbSetCurrent(c.slot, value);
      renderAll();
      if(isMobile()) setView("detail");
    };

    btnCopy.onclick = async () => {
      const text = TOOLBOX.current[c.slot];
      if(!text) return;
      try{
        await navigator.clipboard.writeText(text);
        showToast("Kopiert: " + text);
      }catch{
        const tmp = document.createElement("textarea");
        tmp.value = text;
        document.body.appendChild(tmp);
        tmp.select();
        document.execCommand("copy");
        tmp.remove();
        showToast("Kopiert: " + text);
      }
    };

    btnMark.onclick = () => {
      const text = TOOLBOX.current[c.slot];
      if(!text) return;
      const used = tbIsUsed(c.poolKey, text);
      if(used) tbUnmarkUsed(c.poolKey, text);
      else tbMarkUsed(c.poolKey, text);
      saveWorld();
      renderAll();
    };

    btnReroll.onclick = () => {
      const value = tbDraw(c.poolKey);
      if(!value){ showToast("Pool ist leer: " + c.poolKey); return; }
      tbSetCurrent(c.slot, value);
      renderAll();
    };

    elEntityList.appendChild(wrap);
  }

  renderToolboxDetail();
  if(isMobile()) setView("list");
}

function renderSeedsList(){
  elListTitle.textContent = `üì¶ Seeds (${(TOOLBOX.seeds || []).length})`;
  elEntityList.innerHTML = "";

  const seeds = (TOOLBOX.seeds || []).slice()
    .sort((a,b)=>String(a.label||"").localeCompare(String(b.label||""),'de'));

  // Header buttons
  const header = document.createElement("div");
  header.className = "tb-card";
  header.innerHTML = `
    <div class="tb-row">
      <div class="grow">
        <div class="tb-value">üì¶ Seeds</div>
        <div class="tb-mini">Seeds k√∂nnen Name/Rolle/Hook etc. enthalten. Du kannst einzelne Teile als benutzt markieren.</div>
      </div>
      <button id="btnSeedRandom" class="center">üé≤ Random Seed</button>
    </div>
  `;
  elEntityList.appendChild(header);

  header.querySelector("#btnSeedRandom").onclick = () => {
    if(seeds.length === 0){ showToast("Keine Seeds vorhanden."); return; }
    let pick = null;

    if(TOOLBOX.settings.onlyUnused){
      const unused = seeds.filter(s => !tbSeedIsUsed(s));
      pick = unused.length ? randPick(unused) : randPick(seeds);
    } else {
      pick = randPick(seeds);
    }

    state.selectedSeedId = (pick.id || ("seed-"+slugifyNameToId(pick.label)));
    TOOLBOX.current.seedId = state.selectedSeedId;
    saveWorld();

    renderAll();
    if(isMobile()) setView("detail");
  };

  for(const s of seeds){
    const sid = (s.id || ("seed-"+slugifyNameToId(s.label)));
    const used = tbSeedIsUsed(s);
    const btn = document.createElement("button");
    btn.className = "seed-btn" + (state.selectedSeedId === sid ? " active" : "");
    btn.innerHTML = `
      <div class="title">${escapeHtml(s.label || "Seed")}${used ? " ¬∑ ‚úÖ" : ""}</div>
      <div class="meta">${escapeHtml(seedMeta(s))}</div>
      <div class="mini">${escapeHtml(seedSummary(s))}</div>
    `;
    btn.onclick = () => {
      state.selectedSeedId = sid;
      TOOLBOX.current.seedId = sid;
      saveWorld();
      renderAll();
      if(isMobile()) setView("detail");
    };
    elEntityList.appendChild(btn);
  }

  renderSeedsDetail();
  if(isMobile()) setView("list");
}

/* =========================
   TOOLBOX DETAIL / WORKBENCH
========================= */
function getAllNpcCategories(){
  const set = new Set();
  for(const n of NPCS){ (n.categories || []).forEach(c => set.add(c)); }
  set.add("Toolbox/Spontan");
  set.add("Unkategorisiert");
  return Array.from(set).sort((a,b)=>a.localeCompare(b,'de'));
}

async function copyToClipboard(text){
  try{
    await navigator.clipboard.writeText(text);
    showToast("Kopiert ‚úÖ");
  }catch{
    const tmp = document.createElement("textarea");
    tmp.value = text;
    document.body.appendChild(tmp);
    tmp.select();
    document.execCommand("copy");
    tmp.remove();
    showToast("Kopiert ‚úÖ");
  }
}

function renderToolboxDetail(){
  elDetailActions.style.display = "none";
  elDetailActionsHr.style.display = "none";
  detailIdHint.textContent = "";

  elDetailTitle.textContent = "üé≤ Toolbox ‚Äì Workbench";
  elDetailSub.textContent = "Du markierst nur das als benutzt, was du wirklich benutzt hast.";

  const c = TOOLBOX.current;

  const slots = [
    { slot: "name", label: "Name", poolKey: "names.human" },
    { slot: "role", label: "Rolle", poolKey: "roles" },
    { slot: "trait1", label: "Trait 1", poolKey: "traits" },
    { slot: "trait2", label: "Trait 2", poolKey: "traits" },
    { slot: "hook", label: "Hook", poolKey: "hooks" },
    { slot: "voice", label: "Voice", poolKey: "voices" },
  ];

  const categoryOptions = getAllNpcCategories();
  const placeOptions = PLACES.slice().sort((a,b)=>a.name.localeCompare(b.name,'de'));

  const defaultCat = TOOLBOX.settings.defaultCategory || "Toolbox/Spontan";
  const defaultPlace = TOOLBOX.settings.defaultPlaceId || "";

  const body = [];
  body.push(`<div class="tb-card">
    <div class="tb-row">
      <div class="grow"><div class="tb-label">Default-Kategorie f√ºrs Speichern</div></div>
      <select id="tbDefaultCat" class="grow" style="min-width:220px;">
        ${categoryOptions.map(x => `<option value="${escapeHtml(x)}" ${x===defaultCat?"selected":""}>${escapeHtml(x)}</option>`).join("")}
      </select>
    </div>

    <div class="tb-row">
      <div class="grow"><div class="tb-label">Default-Ort (optional, verlinkt als placeId)</div></div>
      <select id="tbDefaultPlace" class="grow" style="min-width:220px;">
        <option value="" ${defaultPlace===""?"selected":""}>(kein Ort)</option>
        ${placeOptions.map(p => `<option value="${escapeHtml(p.id)}" ${p.id===defaultPlace?"selected":""}>${escapeHtml(p.name)} ¬∑ ${escapeHtml(p.id)}</option>`).join("")}
      </select>
    </div>

    <div class="tb-mini muted">Tipp: Ort-IDs kannst du bei Orten im Detail mit ‚ÄûüÜî ID kopieren‚Äú holen.</div>
  </div>`);

  for(const s of slots){
    const val = c[s.slot];
    const used = val ? tbIsUsed(s.poolKey, val) : false;
    body.push(`
      <div class="tb-card">
        <div class="tb-row">
          <div class="grow">
            <div class="tb-label">${escapeHtml(s.label)}</div>
            <div class="tb-value">${val ? escapeHtml(val) : "<span class='muted'>‚Äî</span>"}</div>
            <div class="tb-mini">${val ? (used ? "‚úÖ benutzt markiert" : "üÜï unbenutzt") : "Zieh links einen Wert."}</div>
          </div>
          <div class="tb-btns">
            <button data-tbcopy="${s.slot}" ${val?"":"disabled"}>üìã</button>
            <button data-tbmark="${s.slot}" ${val?"":"disabled"}>${used ? "‚Ü©Ô∏é" : "‚úÖ"}</button>
            <button data-tbreroll="${s.slot}">üé≤</button>
          </div>
        </div>
      </div>
    `);
  }

  body.push(`
    <div class="tb-card">
      <div class="tb-row">
        <div class="grow">
          <div class="tb-value">‚ûï Als NPC speichern</div>
          <div class="tb-mini">Speichert nur die aktuell gezogenen Bausteine. Benutzt-Status wird nur durch ‚úÖ gesetzt (nicht automatisch).</div>
        </div>
        <button id="tbSaveNpc" class="center">‚ûï Speichern</button>
      </div>
      <div class="tb-mini muted">Ergebnis landet in deinen normalen NPCs (Kategorie: Toolbox/Spontan + Default-Kategorie).</div>
    </div>
  `);

  elDetailBody.innerHTML = body.join("\n");

  const selCat = document.getElementById("tbDefaultCat");
  const selPlace = document.getElementById("tbDefaultPlace");

  selCat.onchange = () => { TOOLBOX.settings.defaultCategory = selCat.value; saveWorld(); };
  selPlace.onchange = () => { TOOLBOX.settings.defaultPlaceId = selPlace.value; saveWorld(); };

  elDetailBody.querySelectorAll("[data-tbcopy]").forEach(btn => {
    btn.onclick = async () => {
      const slot = btn.getAttribute("data-tbcopy");
      const text = TOOLBOX.current[slot];
      if(!text) return;
      await copyToClipboard(text);
    };
  });

  elDetailBody.querySelectorAll("[data-tbmark]").forEach(btn => {
    btn.onclick = () => {
      const slot = btn.getAttribute("data-tbmark");
      const poolKey = tbPoolKeyFor(slot);
      const text = TOOLBOX.current[slot];
      if(!text) return;
      const used = tbIsUsed(poolKey, text);
      if(used) tbUnmarkUsed(poolKey, text); else tbMarkUsed(poolKey, text);
      saveWorld();
      renderAll();
    };
  });

  elDetailBody.querySelectorAll("[data-tbreroll]").forEach(btn => {
    btn.onclick = () => {
      const slot = btn.getAttribute("data-tbreroll");
      const poolKey = tbPoolKeyFor(slot);
      const value = tbDraw(poolKey);
      if(!value){ showToast("Pool leer: " + poolKey); return; }
      tbSetCurrent(slot, value);
      renderAll();
    };
  });

  document.getElementById("tbSaveNpc").onclick = () => {
    const name = TOOLBOX.current.name ? TOOLBOX.current.name.trim() : "";
    if(!name){ alert("Bitte zuerst einen Namen ziehen."); return; }

    const looksEmoji = name[0] && !(/[A-Za-z0-9√Ñ√ñ√ú√§√∂√º√ü]/.test(name[0]));
    const npcName = looksEmoji ? name : ("üü¢ " + name);

    const role = TOOLBOX.current.role || "";
    const trait1 = TOOLBOX.current.trait1 || "";
    const trait2 = TOOLBOX.current.trait2 || "";
    const hook = TOOLBOX.current.hook || "";
    const voice = TOOLBOX.current.voice || "";

    const cats = uniq(["Toolbox/Spontan", (TOOLBOX.settings.defaultCategory || "Toolbox/Spontan")]);
    const placeIds = TOOLBOX.settings.defaultPlaceId ? [TOOLBOX.settings.defaultPlaceId] : [];

    let baseId = slugifyNameToId(name);
    let id = baseId;
    let i = 2;
    while(NPCS.some(n => n.id === id)){ id = baseId + "-" + i; i++; }

    const fields = {
      "Rolle / Funktion": role || "‚Äî",
      "Auftreten & Eindruck (inkl. Aussehen)": [trait1, trait2].filter(Boolean).join(" ¬∑ ") || "‚Äî",
      "Motivation (offen)": hook || "‚Äî",
      "Notizen f√ºr den SL": voice || "‚Äî"
    };

    const npc = { id, name: npcName, categories: cats, tags: [], placeIds, fields };
    NPCS.push(npc);
    saveWorld();
    showToast("NPC gespeichert ‚úÖ");
    openNpcById(id);
  };
}

function renderSeedsDetail(){
  elDetailActions.style.display = "none";
  elDetailActionsHr.style.display = "none";
  detailIdHint.textContent = "";

  const seed = state.selectedSeedId ? getSeedById(state.selectedSeedId) : null;

  elDetailTitle.textContent = "üì¶ Seed";
  elDetailSub.textContent = seed ? (seed.tags && seed.tags.length ? seed.tags.join(", ") : "‚Äî") : "Seed ausw√§hlen oder Random ziehen.";

  if(!seed){
    elDetailBody.innerHTML = `<div class="muted">‚Äî</div>`;
    return;
  }

  const usedSeed = tbSeedIsUsed(seed);
  const parts = seedParts(seed);

  const partsHtml = parts.map(p => {
    const used = tbIsUsed(p.poolKey, p.value);
    return `
      <div class="tb-card">
        <div class="tb-row">
          <div class="grow">
            <div class="tb-label">${escapeHtml(p.label)}</div>
            <div class="tb-value">${escapeHtml(p.value)}</div>
            <div class="tb-mini">${used ? "‚úÖ benutzt markiert" : "üÜï unbenutzt"} ¬∑ Pool: <span class="muted">${escapeHtml(p.poolKey)}</span></div>
          </div>
          <div class="tb-btns">
            <button data-seedcopy="${escapeHtml(p.key)}">üìã</button>
            <button data-seeduse="${escapeHtml(p.key)}">${used ? "‚Ü©Ô∏é" : "‚úÖ"}</button>
          </div>
        </div>
      </div>
    `;
  }).join("\n");

  elDetailBody.innerHTML = `
    <div class="tb-card">
      <div class="tb-row">
        <div class="grow">
          <div class="tb-value">${escapeHtml(seed.label || "Seed")}${usedSeed ? " ¬∑ ‚úÖ benutzt" : ""}</div>
          <div class="tb-mini">${escapeHtml(seedSummary(seed))}</div>
          ${seed.note ? `<div class="tb-mini" style="margin-top:6px; white-space:pre-wrap;">${escapeHtml(seed.note)}</div>` : ""}
        </div>
      </div>

      <div class="tb-btns">
        <button id="btnSeedWorkbench">‚û°Ô∏è In Workbench</button>
        <button id="btnSeedMark">${usedSeed ? "‚Ü©Ô∏é Seed unbenutzt" : "‚úÖ Seed benutzt"}</button>
      </div>

      <div class="tb-mini muted">‚ÄûIn Workbench‚Äú kopiert die Seed-Felder in deine Bausteine (ohne automatisch used zu setzen).</div>
    </div>

    ${partsHtml || `<div class="muted">Dieser Seed hat keine Teile (Name/Rolle/Hook/etc). Nur Text.</div>`}
  `;

  document.getElementById("btnSeedWorkbench").onclick = () => {
    // only set if present
    if(seed.name) tbSetCurrent("name", seed.name);
    if(seed.role) tbSetCurrent("role", seed.role);
    if(seed.hook) tbSetCurrent("hook", seed.hook);
    if(seed.voice) tbSetCurrent("voice", seed.voice);

    // Trait: put into trait1 if empty else trait2
    if(seed.trait){
      if(!TOOLBOX.current.trait1) tbSetCurrent("trait1", seed.trait);
      else if(!TOOLBOX.current.trait2) tbSetCurrent("trait2", seed.trait);
      else tbSetCurrent("trait2", seed.trait);
    }

    showToast("In Workbench √ºbernommen ‚úÖ");
    // optionally switch tab
    state.tbTab = "blocks";
    renderAll();
    if(isMobile()) setView("detail");
  };

  document.getElementById("btnSeedMark").onclick = () => {
    if(tbSeedIsUsed(seed)) tbSeedUnmarkUsed(seed);
    else tbSeedMarkUsed(seed);
    saveWorld();
    renderAll();
  };

  elDetailBody.querySelectorAll("[data-seedcopy]").forEach(btn => {
    btn.onclick = async () => {
      const key = btn.getAttribute("data-seedcopy");
      const map = { name: seed.name, role: seed.role, hook: seed.hook, trait: seed.trait, voice: seed.voice };
      const text = map[key];
      if(text) await copyToClipboard(text);
    };
  });

  elDetailBody.querySelectorAll("[data-seeduse]").forEach(btn => {
    btn.onclick = () => {
      const key = btn.getAttribute("data-seeduse");
      const map = {
        name: { poolKey:"names.human", value: seed.name },
        role: { poolKey:"roles", value: seed.role },
        hook: { poolKey:"hooks", value: seed.hook },
        trait:{ poolKey:"traits", value: seed.trait },
        voice:{ poolKey:"voices", value: seed.voice },
      };
      const p = map[key];
      if(!p || !p.value) return;
      const used = tbIsUsed(p.poolKey, p.value);
      if(used) tbUnmarkUsed(p.poolKey, p.value);
      else tbMarkUsed(p.poolKey, p.value);
      saveWorld();
      renderAll();
    };
  });
}

/* =========================
   RENDER: Detail (NPC/Orte/Toolbox)
========================= */
function renderDetail(ent){
  if(state.mode === "toolbox"){
    if(state.tbTab === "seeds") renderSeedsDetail();
    else renderToolboxDetail();
    return;
  }

  if(!ent){
    elDetailActions.style.display = "none";
    elDetailActionsHr.style.display = "none";
    detailIdHint.textContent = "";
    elDetailTitle.textContent = "Ausw√§hlen";
    elDetailSub.textContent = "‚Äî";
    elDetailBody.textContent = "‚Äî";
    return;
  }

  elDetailActions.style.display = "flex";
  elDetailActionsHr.style.display = "block";
  elDetailTitle.textContent = ent.name;

  detailIdHint.textContent = `ID: ${ent.id}`;

  const cats = (ent.categories || []);
  const tags = (ent.tags || []);
  const subtitleParts = [];
  if(cats.length) subtitleParts.push(cats.join(", "));
  if(state.mode === "places"){
    if(ent.type) subtitleParts.push(`Typ: ${ent.type}`);
    if(ent.parentId) subtitleParts.push(`Parent: ${ent.parentId}`);
  }
  if(tags.length) subtitleParts.push(`Tags: ${tags.join(", ")}`);
  elDetailSub.textContent = subtitleParts.join(" ¬∑ ") || "‚Äî";

  const entries = Object.entries(ent.fields || {});

  let linksHtml = "";
  if(state.mode === "npcs"){
    const placeIds = uniq(ent.placeIds || []);
    if(placeIds.length){
      linksHtml += `
        <div class="hr"></div>
        <h2>Orte</h2>
        <div class="grid">
          ${placeIds.map(pid => {
            const p = PLACES.find(x => x.id === pid);
            const label = p ? p.name : `(unbekannt) ${pid}`;
            const sub = p ? (p.type || "Ort") : "ID fehlt in places";
            return `
              <button onclick="window.__openPlace('${pid}')">
                <div><b>${escapeHtml(label)}</b></div>
                <div class="sub">${escapeHtml(sub)} ¬∑ <span class="muted">${escapeHtml(pid)}</span></div>
              </button>
            `;
          }).join("")}
        </div>
      `;
    }
  } else {
    const children = PLACES.filter(p => p.parentId === ent.id).sort((a,b)=>a.name.localeCompare(b.name,'de'));
    if(children.length){
      linksHtml += `
        <div class="hr"></div>
        <h2>Unterorte</h2>
        <div class="grid">
          ${children.map(ch => `
            <button onclick="window.__openPlace('${ch.id}')">
              <div><b>${escapeHtml(ch.name)}</b></div>
              <div class="sub">${escapeHtml(ch.type || "Unterort")} ¬∑ <span class="muted">${escapeHtml(ch.id)}</span></div>
            </button>
          `).join("")}
        </div>
      `;
    }

    const npcIds = uniq(ent.npcIds || []);
    if(npcIds.length){
      linksHtml += `
        <div class="hr"></div>
        <h2>NPCs hier</h2>
        <div class="grid">
          ${npcIds.map(nid => {
            const n = NPCS.find(x => x.id === nid);
            const label = n ? n.name : `(unbekannt) ${nid}`;
            const sub = n ? (n.fields?.["Rolle / Funktion"] || n.fields?.["Rolle"] || "NPC") : "ID fehlt in npcs";
            return `
              <button onclick="window.__openNpc('${nid}')">
                <div><b>${escapeHtml(label)}</b></div>
                <div class="sub">${escapeHtml(sub)} ¬∑ <span class="muted">${escapeHtml(nid)}</span></div>
              </button>
            `;
          }).join("")}
        </div>
      `;
    }
  }

  elDetailBody.innerHTML = `
    <div class="pillwrap">
      ${cats.map(c => `<span class="pill">${escapeHtml(c)}</span>`).join("")}
      ${tags.map(t => `<span class="pill">${escapeHtml(t)}</span>`).join("")}
    </div>
    <div class="kv">
      ${entries.map(([k,v]) => `
        <div class="k">${escapeHtml(k)}</div>
        <div class="v">${escapeHtml(v)}</div>
      `).join("")}
    </div>
    ${linksHtml}
  `;
}

/* =========================
   COPY ID (NPC/Ort)
========================= */
btnCopyId.onclick = async () => {
  const ent = getSelectedEntity();
  if(!ent) return;
  await copyToClipboard(ent.id);
};

/* =========================
   EDIT MODAL (nur NPC/Ort)
========================= */
const editBg = document.getElementById("editBg");
const editText = document.getElementById("editText");
const editInfo = document.getElementById("editInfo");
const btnSaveEdit = document.getElementById("btnSaveEdit");
const btnCancelEdit = document.getElementById("btnCancelEdit");
let editing = null;

function openEdit(ent){
  if(!ent) return;
  editing = { mode: state.mode, id: ent.id };
  editInfo.textContent = "";
  editText.value = (state.mode === "npcs") ? npcToTextBlock(ent) : placeToTextBlock(ent);
  editBg.style.display = "flex";
}
function closeEdit(){ editBg.style.display = "none"; editing = null; }

btnEditEntity.onclick = () => openEdit(getSelectedEntity());
btnCancelEdit.onclick = closeEdit;
editBg.addEventListener("click", (e) => { if(e.target === editBg) closeEdit(); });

btnSaveEdit.onclick = () => {
  if(!editing){ editInfo.textContent = "Nichts zum Speichern."; return; }

  if(editing.mode === "npcs"){
    const { parsed, errors } = parseNpcBlocks(editText.value);
    if(parsed.length !== 1){
      editInfo.textContent = parsed.length === 0 ? (errors[0] || "Kein NPC erkannt.") : "Bitte genau 1 NPC im Editor lassen.";
      return;
    }
    const updated = parsed[0];
    updated.id = editing.id;

    const idx = NPCS.findIndex(n => n.id === editing.id);
    if(idx === -1){ editInfo.textContent = "NPC nicht gefunden."; return; }

    const placeSet = new Set(PLACES.map(p => p.id));
    const unknownPlaces = validateIds(updated.placeIds, placeSet);
    if(unknownPlaces.length){
      const ok = confirm(`Warnung: Unbekannte Ort-IDs:\n- ${unknownPlaces.join("\n- ")}\n\nTrotzdem speichern?`);
      if(!ok) return;
    }

    updated.placeIds = uniq(updated.placeIds || []);
    NPCS[idx] = updated;
  } else if(editing.mode === "places") {
    const { parsed, errors, warnings } = parsePlaceBlocks(editText.value);
    if(parsed.length !== 1){
      editInfo.textContent = parsed.length === 0 ? (errors[0] || "Kein Ort erkannt.") : "Bitte genau 1 Ort im Editor lassen.";
      return;
    }

    const updated = parsed[0];
    updated.id = editing.id;

    const idx = PLACES.findIndex(p => p.id === editing.id);
    if(idx === -1){ editInfo.textContent = "Ort nicht gefunden."; return; }

    const npcSet = new Set(NPCS.map(n => n.id));
    const placeSet = new Set(PLACES.map(p => p.id));
    const unknownNpcs = validateIds(updated.npcIds, npcSet);
    const unknownParent = (updated.parentId && !placeSet.has(updated.parentId)) ? [updated.parentId] : [];

    let warn = [];
    if(warnings.length) warn.push(warnings.join("\n"));
    if(unknownNpcs.length) warn.push("Unbekannte NPC-IDs:\n- " + unknownNpcs.join("\n- "));
    if(unknownParent.length) warn.push("Unbekannte Parent-ID:\n- " + unknownParent.join("\n- "));
    if(warn.length){
      const ok = confirm("Warnung:\n\n" + warn.join("\n\n") + "\n\nTrotzdem speichern?");
      if(!ok) return;
    }

    updated.npcIds = uniq(updated.npcIds || []);
    PLACES[idx] = updated;
  }

  saveWorld();
  renderAll();
  applyMobileVisibility();
  closeEdit();
};

/* =========================
   IMPORT MODAL (NPC/Ort/Toolbox)
========================= */
const importBg = document.getElementById("importBg");
const importText = document.getElementById("importText");
const importInfo = document.getElementById("importInfo");
const btnDoImport = document.getElementById("btnDoImport");
const btnImportModeNpcs = document.getElementById("btnImportModeNpcs");
const btnImportModePlaces = document.getElementById("btnImportModePlaces");
const btnImportModeToolbox = document.getElementById("btnImportModeToolbox");
const importHeaderTitle = document.getElementById("importHeaderTitle");
const importFormatHelp = document.getElementById("importFormatHelp");
const toolboxImportControls = document.getElementById("toolboxImportControls");
const tbImportTarget = document.getElementById("tbImportTarget");
const tbImportModeSel = document.getElementById("tbImportMode");
let importMode = "npcs";

function setImportMode(mode){
  importMode = mode;
  btnImportModeNpcs.classList.toggle("active", mode === "npcs");
  btnImportModePlaces.classList.toggle("active", mode === "places");
  btnImportModeToolbox.classList.toggle("active", mode === "toolbox");
  toolboxImportControls.style.display = (mode === "toolbox") ? "block" : "none";

  if(mode === "npcs"){
    importHeaderTitle.textContent = "‚¨áÔ∏è Import: NPC-Textbl√∂cke";
    importFormatHelp.innerHTML =
      `Start je NPC mit <code>### üü¢ Name</code>, dann <code>**Feld:** Wert</code>.<br>` +
      `Optional: <code>**Kategorien:** ...</code> ¬∑ <code>**Tags:** ...</code> ¬∑ <code>**Orte:** id1, id2</code><br>` +
      `Trennen mit <code>---</code>.`;
    btnDoImport.textContent = "‚úÖ Importieren (NPCs)";
  } else if(mode === "places") {
    importHeaderTitle.textContent = "‚¨áÔ∏è Import: Orte (strict IDs)";
    importFormatHelp.innerHTML =
      `Start je Ort mit <code>### Name</code> und <code>**ID:** place-id</code>.<br>` +
      `Optional: <code>**Typ:**</code> ¬∑ <code>**Parent:** parent-id</code> ¬∑ <code>**Kategorien:**</code> ¬∑ <code>**Tags:**</code> ¬∑ <code>**NPCs:** npc-id1, npc-id2</code><br>` +
      `Weitere Felder als <code>**Feld:** Wert</code>. Trennen mit <code>---</code>.`;
    btnDoImport.textContent = "‚úÖ Importieren (Orte)";
  } else {
    importHeaderTitle.textContent = "‚¨áÔ∏è Import: Toolbox (Pools/Seeds)";
    importFormatHelp.innerHTML =
      `Pools: 1 Eintrag pro Zeile (oder JSON-Array).<br>` +
      `Seeds: <code>Label | tags, tags | note ...</code> (note kann <code>name=</code>, <code>role=</code>, <code>hook=</code> enthalten) oder JSON-Array.<br>` +
      `Beispiel Seed: <code>M√ºde Wache | Phandalin, Guard | name=Rurik; role=Wache; hook=Hat was gesehen</code>`;
    btnDoImport.textContent = "‚úÖ Importieren (Toolbox)";
  }
}

function openImport(){
  importInfo.textContent = "";
  importText.value = "";
  importBg.style.display = "flex";
  // default to current view
  if(state.mode === "places") setImportMode("places");
  else if(state.mode === "toolbox") setImportMode("toolbox");
  else setImportMode("npcs");
}
function closeImport(){ importBg.style.display = "none"; }

document.getElementById("btnImport").onclick = openImport;
document.getElementById("btnCloseImport").onclick = closeImport;
importBg.addEventListener("click", (e) => { if(e.target === importBg) closeImport(); });

btnImportModeNpcs.onclick = () => setImportMode("npcs");
btnImportModePlaces.onclick = () => setImportMode("places");
btnImportModeToolbox.onclick = () => setImportMode("toolbox");

btnDoImport.onclick = () => {
  if(importMode === "npcs"){
    const { parsed, errors } = parseNpcBlocks(importText.value);
    if(parsed.length === 0){
      importInfo.textContent = errors.length ? "Keine NPCs erkannt. Hinweis: " + errors[0] : "Keine NPCs erkannt.";
      return;
    }

    const map = new Map(NPCS.map(n => [n.id, n]));
    for(const n of parsed){
      if(map.has(n.id)){ map.set(n.id, n); continue; }
      const best = findBestFuzzyMatch(n, NPCS);
      if(best && best.score >= 0.88){
        const ok = confirm(
          `Fuzzy-Match gefunden:\n\nImport:   ${n.name}\nVorhanden:${best.npc.name}\n\n√Ñhnlichkeit: ${(best.score*100).toFixed(0)}%\n\n√úberschreiben?`
        );
        if(ok){ n.id = best.npc.id; map.set(best.npc.id, n); continue; }
      }
      map.set(n.id, n);
    }

    const placeSet = new Set(PLACES.map(p => p.id));
    const unknownAll = uniq(parsed.flatMap(n => validateIds(n.placeIds || [], placeSet)));
    if(unknownAll.length){
      const ok = confirm(`Warnung: Im Import sind unbekannte Ort-IDs referenziert:\n- ${unknownAll.join("\n- ")}\n\nTrotzdem importieren?`);
      if(!ok) return;
    }

    NPCS = Array.from(map.values());
    saveWorld();
    importInfo.textContent = `‚úÖ Importiert: ${parsed.length} NPC(s).` + (errors.length ? ` Hinweise: ${errors.length}` : "");
  }
  else if(importMode === "places"){
    const { parsed, errors, warnings } = parsePlaceBlocks(importText.value);
    if(parsed.length === 0){
      importInfo.textContent = errors.length ? "Keine Orte erkannt. Hinweis: " + errors[0] : "Keine Orte erkannt.";
      return;
    }

    const npcSet = new Set(NPCS.map(n => n.id));
    const placeSetExisting = new Set(PLACES.map(p => p.id));
    const unknownNpcs = uniq(parsed.flatMap(p => validateIds(p.npcIds || [], npcSet)));
    const unknownParents = uniq(parsed
      .map(p => p.parentId)
      .filter(pid => pid && !placeSetExisting.has(pid) && !parsed.some(pp => pp.id === pid)));

    let warnParts = [];
    if(warnings.length) warnParts.push(warnings.join("\n"));
    if(unknownNpcs.length) warnParts.push("Unbekannte NPC-IDs:\n- " + unknownNpcs.join("\n- "));
    if(unknownParents.length) warnParts.push("Unbekannte Parent-IDs:\n- " + unknownParents.join("\n- "));
    if(warnParts.length){
      const ok = confirm("Warnung:\n\n" + warnParts.join("\n\n") + "\n\nTrotzdem importieren?");
      if(!ok) return;
    }

    const map = new Map(PLACES.map(p => [p.id, p]));
    for(const p of parsed){ map.set(p.id, p); }
    PLACES = Array.from(map.values());
    saveWorld();
    importInfo.textContent = `‚úÖ Importiert: ${parsed.length} Ort(e).` + (errors.length ? ` Hinweise: ${errors.length}` : "");
  }
  else {
    // toolbox
    makeDefaultToolboxIfMissing();
    tbEnsureUsedKeys();

    const target = tbImportTarget.value;
    const mode = tbImportModeSel.value; // append/replace
    const ref = getTbPoolRef(target);
    if(!ref){ importInfo.textContent = "Unbekanntes Ziel: " + target; return; }

    const { items, seeds, errors } = parseToolboxImport(importText.value, target);
    if(target === "seeds"){
      if(seeds.length === 0){
        importInfo.textContent = errors.length ? ("Keine Seeds erkannt. " + errors[0]) : "Keine Seeds erkannt.";
        return;
      }

      const existing = Array.isArray(TOOLBOX.seeds) ? TOOLBOX.seeds : [];
      if(mode === "replace"){
        TOOLBOX.seeds = seeds;
      } else {
        // append with id de-dupe
        const map = new Map();
        for(const s of existing){
          const sid = String(s.id || ("seed-"+slugifyNameToId(s.label||"seed")));
          map.set(sid, { ...s, id: sid });
        }
        for(const s of seeds){
          const sid = String(s.id || ("seed-"+slugifyNameToId(s.label||"seed")));
          map.set(sid, { ...s, id: sid });
        }
        TOOLBOX.seeds = Array.from(map.values());
      }
      saveWorld();
      importInfo.textContent = `‚úÖ Toolbox: Seeds importiert (${seeds.length}).` + (errors.length ? ` Hinweise: ${errors.length}` : "");
    } else {
      if(items.length === 0){
        importInfo.textContent = errors.length ? ("Keine Eintr√§ge erkannt. " + errors[0]) : "Keine Eintr√§ge erkannt.";
        return;
      }

      // write pool
      if(ref.kind === "names"){
        TOOLBOX.pools.names = TOOLBOX.pools.names || {};
        const cur = Array.isArray(TOOLBOX.pools.names[ref.race]) ? TOOLBOX.pools.names[ref.race] : [];
        TOOLBOX.pools.names[ref.race] = (mode === "replace") ? uniq(items) : uniq(cur.concat(items));
      } else if(ref.kind === "list"){
        const cur = Array.isArray(TOOLBOX.pools[ref.key]) ? TOOLBOX.pools[ref.key] : [];
        TOOLBOX.pools[ref.key] = (mode === "replace") ? uniq(items) : uniq(cur.concat(items));
      }

      saveWorld();
      importInfo.textContent = `‚úÖ Toolbox: ${target} importiert (${items.length}).` + (errors.length ? ` Hinweise: ${errors.length}` : "");
    }
  }

  renderAll();
  if(isMobile()) setView("cats");
  applyMobileVisibility();
};

/* =========================
   SEARCH
========================= */
elSearch.addEventListener("input", (e) => {
  if(state.mode === "toolbox") return;
  state.search = e.target.value.trim();
  renderEntityList();
});

/* =========================
   EXPORT / RESET
========================= */
function getWorldObject(){
  return { npcs: NPCS, places: PLACES, toolbox: TOOLBOX };
}
document.getElementById("btnExport").onclick = () => {
  const data = JSON.stringify(getWorldObject(), null, 2);
  const blob = new Blob([data], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "world-export.json";
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
};
document.getElementById("btnExportClipboard").onclick = async () => {
  const data = JSON.stringify(getWorldObject(), null, 2);
  try{
    await navigator.clipboard.writeText(data);
    showToast("Export JSON in Zwischenablage ‚úÖ");
  }catch{
    const ok = confirm("Clipboard nicht erlaubt. Soll der JSON-Text in einem Prompt-Feld angezeigt werden?");
    if(!ok) return;
    window.prompt("Kopiere den JSON-Text:", data);
  }
};
document.getElementById("btnReset").onclick = () => {
  const ok = confirm("Wirklich alle NPCs UND Orte l√∂schen? (Toolbox bleibt)");
  if(!ok) return;
  NPCS = [];
  PLACES = [];
  saveWorld();
  state.selectedCategory = null;
  state.selectedEntityId = null;
  state.search = "";
  elSearch.value = "";
  state.view = "cats";
  renderAll();
  applyMobileVisibility();
};

/* =========================
   SYNC LOAD (inkl. Toolbox mergeUsed)
========================= */
async function syncLoad(){
  const btn = document.getElementById("btnSyncLoad");
  btn.disabled = true;
  btnTopSync.disabled = true;
  elSyncStatus.textContent = "Sync: lade‚Ä¶";

  try{
    const res = await fetch(REMOTE_DATA_URL + "?t=" + Date.now(), { cache: "no-store" });
    if(!res.ok) throw new Error("HTTP " + res.status);
    const data = await res.json();

    let npcsIncoming = [];
    let placesIncoming = [];
    let toolboxIncoming = null;

    if(Array.isArray(data)){
      npcsIncoming = data;
    } else if(data && typeof data === "object"){
      if(Array.isArray(data.npcs)) npcsIncoming = data.npcs;
      if(Array.isArray(data.places)) placesIncoming = data.places;
      if(data.toolbox && typeof data.toolbox === "object") toolboxIncoming = data.toolbox;

      if(!Array.isArray(data.npcs) && !Array.isArray(data.places)){
        throw new Error("Unerwartetes JSON-Format (erwarte Array oder {npcs:[...], places:[...]})");
      }
    } else {
      throw new Error("Unerwartetes JSON-Format");
    }

    // NPCs
    NPCS = (npcsIncoming || [])
      .filter(obj => obj && typeof obj === "object" && typeof obj.name === "string" && obj.name.trim().length > 0)
      .map(n => ({
        id: (n.id && String(n.id).trim()) ? String(n.id) : slugifyNameToId(n.name),
        name: String(n.name),
        categories: Array.isArray(n.categories) ? n.categories : (n.categories ? [String(n.categories)] : ["Unkategorisiert"]),
        tags: Array.isArray(n.tags) ? n.tags : (n.tags ? [String(n.tags)] : []),
        placeIds: Array.isArray(n.placeIds) ? n.placeIds.map(String) : [],
        fields: (n.fields && typeof n.fields === "object") ? n.fields : {}
      }));

    // Places
    PLACES = (placesIncoming || [])
      .filter(obj => obj && typeof obj === "object" && typeof obj.name === "string" && obj.name.trim().length > 0)
      .map(p => ({
        id: (p.id && String(p.id).trim()) ? String(p.id) : slugifyNameToId(p.name),
        name: String(p.name),
        type: p.type ? String(p.type) : "",
        parentId: p.parentId ? String(p.parentId) : "",
        categories: Array.isArray(p.categories) ? p.categories : (p.categories ? [String(p.categories)] : ["Unkategorisiert"]),
        tags: Array.isArray(p.tags) ? p.tags : (p.tags ? [String(p.tags)] : []),
        npcIds: Array.isArray(p.npcIds) ? p.npcIds.map(String) : [],
        fields: (p.fields && typeof p.fields === "object") ? p.fields : {}
      }));

    // Toolbox: mergeUsed (pools/settings from remote, used union, seeds from remote)
    if(toolboxIncoming){
      makeDefaultToolboxIfMissing();
      TOOLBOX = mergeToolbox(TOOLBOX, toolboxIncoming, { mode: "mergeUsed" });
      tbEnsureUsedKeys();
    }

    saveWorld();

    state.selectedCategory = null;
    state.selectedEntityId = null;
    state.search = "";
    state.selectedSeedId = null;
    elSearch.value = "";
    state.view = "cats";

    renderAll();
    applyMobileVisibility();

    const now = new Date();
    const hh = String(now.getHours()).padStart(2,"0");
    const mm = String(now.getMinutes()).padStart(2,"0");

    const tbInfo = toolboxIncoming ? " ¬∑ Toolbox: merged" : " ¬∑ Toolbox: lokal";
    elSyncStatus.textContent = `Sync: geladen (NPCs: ${NPCS.length}, Orte: ${PLACES.length})${tbInfo} ¬∑ ${hh}:${mm}`;
    showToast("Sync geladen ‚úÖ");
  }catch(err){
    elSyncStatus.textContent = "Sync: Fehler ‚Äì " + (err?.message || String(err));
  }finally{
    btn.disabled = false;
    btnTopSync.disabled = false;
  }
}
document.getElementById("btnSyncLoad").onclick = syncLoad;

/* =========================
   TOOLBOX TOGGLE / Tabs UI wiring
========================= */
function setToolboxTab(tab){
  state.tbTab = tab;
  renderAll();
  if(isMobile()) setView("list");
}

/* =========================
   MODE SWITCH
========================= */
function collectEntitiesCategoriesForMode(){
  if(state.mode === "npcs") return collectCategories(NPCS);
  if(state.mode === "places") return collectCategories(PLACES);
  return ["‚Äî"];
}

/* =========================
   MAIN RENDER
========================= */
function renderAll(){
  updateModeUi();

  if(state.mode === "toolbox"){
    elCatButtons.innerHTML = "";
    renderEntityList();
    renderDetail(null);
    return;
  }

  renderCategories();
  renderEntityList();
  renderDetail(getSelectedEntity());
}

/* =========================
   INIT
========================= */
makeDefaultToolboxIfMissing();
tbEnsureUsedKeys();
updateModeUi();
renderAll();
applyMobileVisibility();
</script>
</body>
</html>
